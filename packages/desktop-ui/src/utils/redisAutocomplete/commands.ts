/**
 * Redis Command Definitions
 *
 * Comprehensive command metadata for context-aware autocomplete.
 * Each command includes: arguments, options, complexity, examples.
 */

import type { RedisCommand, RedisArgDef } from "./types";

// Helper to create argument definitions
const arg = (
  name: string,
  type: RedisArgDef["type"],
  opts?: Partial<RedisArgDef>
): RedisArgDef => ({
  name,
  type,
  ...opts,
});

// String commands
const STRING_COMMANDS: RedisCommand[] = [
  {
    name: "GET",
    category: "string",
    summary: "Get the string value of a key",
    complexity: "O(1)",
    args: [arg("key", "key")],
    returns: "Bulk string reply: the value of key, or nil",
    example: "GET user:1001:name",
  },
  {
    name: "SET",
    category: "string",
    summary: "Set the string value of a key",
    complexity: "O(1)",
    args: [arg("key", "key"), arg("value", "value")],
    options: [
      { name: "EX", args: [arg("seconds", "timeout")], description: "Set expiry in seconds" },
      { name: "PX", args: [arg("milliseconds", "milliseconds")], description: "Set expiry in milliseconds" },
      { name: "EXAT", args: [arg("timestamp", "timestamp")], description: "Set expiry at Unix timestamp (seconds)" },
      { name: "PXAT", args: [arg("timestamp", "timestamp")], description: "Set expiry at Unix timestamp (milliseconds)" },
      { name: "NX", description: "Only set if key does not exist" },
      { name: "XX", description: "Only set if key already exists" },
      { name: "KEEPTTL", description: "Retain the TTL of the key" },
      { name: "GET", description: "Return the old value" },
      { name: "IFEQ", args: [arg("value", "value")], description: "Only set if current value equals" },
      { name: "IFGT", args: [arg("value", "value")], description: "Only set if current value greater than" },
    ],
    example: 'SET user:1001:name "John Doe" EX 3600 NX',
  },
  {
    name: "SETEX",
    category: "string",
    summary: "Set value with expiration in seconds",
    complexity: "O(1)",
    args: [arg("key", "key"), arg("seconds", "timeout"), arg("value", "value")],
    example: 'SETEX session:abc123 3600 "user_data"',
  },
  {
    name: "SETNX",
    category: "string",
    summary: "Set value only if key does not exist",
    complexity: "O(1)",
    args: [arg("key", "key"), arg("value", "value")],
    example: 'SETNX lock:resource "locked"',
  },
  {
    name: "MGET",
    category: "string",
    summary: "Get values of multiple keys",
    complexity: "O(N)",
    args: [arg("key", "keys", { multiple: true })],
    example: "MGET user:1:name user:2:name user:3:name",
  },
  {
    name: "MSET",
    category: "string",
    summary: "Set multiple key-value pairs",
    complexity: "O(N)",
    args: [arg("key", "key"), arg("value", "value", { multiple: true })],
    example: 'MSET user:1:name "John" user:1:email "john@example.com"',
  },
  {
    name: "INCR",
    category: "string",
    summary: "Increment the integer value by 1",
    complexity: "O(1)",
    args: [arg("key", "key")],
    example: "INCR page:views:homepage",
  },
  {
    name: "INCRBY",
    category: "string",
    summary: "Increment the integer value by given amount",
    complexity: "O(1)",
    args: [arg("key", "key"), arg("increment", "count")],
    example: "INCRBY user:1001:points 100",
  },
  {
    name: "INCRBYFLOAT",
    category: "string",
    summary: "Increment the float value by given amount",
    complexity: "O(1)",
    args: [arg("key", "key"), arg("increment", "value")],
    example: "INCRBYFLOAT product:price 19.99",
  },
  {
    name: "DECR",
    category: "string",
    summary: "Decrement the integer value by 1",
    complexity: "O(1)",
    args: [arg("key", "key")],
    example: "DECR inventory:item:1001",
  },
  {
    name: "DECRBY",
    category: "string",
    summary: "Decrement the integer value by given amount",
    complexity: "O(1)",
    args: [arg("key", "key"), arg("decrement", "count")],
    example: "DECRBY inventory:item:1001 5",
  },
  {
    name: "APPEND",
    category: "string",
    summary: "Append value to existing string",
    complexity: "O(1)",
    args: [arg("key", "key"), arg("value", "value")],
    example: 'APPEND log:today " - New entry"',
  },
  {
    name: "STRLEN",
    category: "string",
    summary: "Get the length of the value",
    complexity: "O(1)",
    args: [arg("key", "key")],
    example: "STRLEN article:content",
  },
  {
    name: "GETRANGE",
    category: "string",
    summary: "Get a substring of the string",
    complexity: "O(N)",
    args: [arg("key", "key"), arg("start", "index"), arg("end", "index")],
    example: "GETRANGE message:1 0 99",
  },
  {
    name: "SETRANGE",
    category: "string",
    summary: "Overwrite part of the string at offset",
    complexity: "O(1)",
    args: [arg("key", "key"), arg("offset", "index"), arg("value", "value")],
    example: 'SETRANGE greeting 6 "Redis"',
  },
  {
    name: "GETEX",
    category: "string",
    summary: "Get value and optionally set expiry",
    complexity: "O(1)",
    args: [arg("key", "key")],
    options: [
      { name: "EX", args: [arg("seconds", "timeout")], description: "Set expiry in seconds" },
      { name: "PX", args: [arg("milliseconds", "milliseconds")], description: "Set expiry in milliseconds" },
      { name: "EXAT", args: [arg("timestamp", "timestamp")], description: "Set expiry at Unix timestamp" },
      { name: "PERSIST", description: "Remove expiration" },
    ],
    example: "GETEX mykey EX 60",
  },
  {
    name: "GETDEL",
    category: "string",
    summary: "Get value and delete the key",
    complexity: "O(1)",
    args: [arg("key", "key")],
    example: "GETDEL temp:data",
  },
];

// Hash commands
const HASH_COMMANDS: RedisCommand[] = [
  {
    name: "HSET",
    category: "hash",
    summary: "Set hash field(s) to value(s)",
    complexity: "O(N)",
    args: [
      arg("key", "key"),
      arg("field", "field"),
      arg("value", "value", { multiple: true }),
    ],
    example: 'HSET user:1001 name "John" email "john@example.com" age "30"',
  },
  {
    name: "HGET",
    category: "hash",
    summary: "Get the value of a hash field",
    complexity: "O(1)",
    args: [arg("key", "key"), arg("field", "field")],
    example: "HGET user:1001 email",
  },
  {
    name: "HGETALL",
    category: "hash",
    summary: "Get all fields and values in a hash",
    complexity: "O(N)",
    args: [arg("key", "key")],
    example: "HGETALL user:1001",
  },
  {
    name: "HMSET",
    category: "hash",
    summary: "Set multiple hash fields",
    complexity: "O(N)",
    args: [arg("key", "key"), arg("field", "field"), arg("value", "value", { multiple: true })],
    deprecated: true,
    example: 'HMSET product:1001 name "Laptop" price "999"',
  },
  {
    name: "HMGET",
    category: "hash",
    summary: "Get values of multiple hash fields",
    complexity: "O(N)",
    args: [arg("key", "key"), arg("field", "fields", { multiple: true })],
    example: "HMGET user:1001 name email age",
  },
  {
    name: "HDEL",
    category: "hash",
    summary: "Delete one or more hash fields",
    complexity: "O(N)",
    args: [arg("key", "key"), arg("field", "fields", { multiple: true })],
    example: "HDEL user:1001 temp_field old_field",
  },
  {
    name: "HEXISTS",
    category: "hash",
    summary: "Check if hash field exists",
    complexity: "O(1)",
    args: [arg("key", "key"), arg("field", "field")],
    example: "HEXISTS user:1001 email",
  },
  {
    name: "HKEYS",
    category: "hash",
    summary: "Get all field names in a hash",
    complexity: "O(N)",
    args: [arg("key", "key")],
    example: "HKEYS user:1001",
  },
  {
    name: "HVALS",
    category: "hash",
    summary: "Get all values in a hash",
    complexity: "O(N)",
    args: [arg("key", "key")],
    example: "HVALS user:1001",
  },
  {
    name: "HLEN",
    category: "hash",
    summary: "Get the number of fields in a hash",
    complexity: "O(1)",
    args: [arg("key", "key")],
    example: "HLEN user:1001",
  },
  {
    name: "HINCRBY",
    category: "hash",
    summary: "Increment hash field by integer",
    complexity: "O(1)",
    args: [arg("key", "key"), arg("field", "field"), arg("increment", "count")],
    example: "HINCRBY user:1001 login_count 1",
  },
  {
    name: "HINCRBYFLOAT",
    category: "hash",
    summary: "Increment hash field by float",
    complexity: "O(1)",
    args: [arg("key", "key"), arg("field", "field"), arg("increment", "value")],
    example: "HINCRBYFLOAT product:1001 price 5.50",
  },
  {
    name: "HSETNX",
    category: "hash",
    summary: "Set hash field only if it does not exist",
    complexity: "O(1)",
    args: [arg("key", "key"), arg("field", "field"), arg("value", "value")],
    example: 'HSETNX user:1001 created_at "2024-01-01"',
  },
  {
    name: "HSCAN",
    category: "hash",
    summary: "Iterate hash fields",
    complexity: "O(N)",
    args: [arg("key", "key"), arg("cursor", "cursor")],
    options: [
      { name: "MATCH", args: [arg("pattern", "pattern")], description: "Match pattern" },
      { name: "COUNT", args: [arg("count", "count")], description: "Return count hint" },
    ],
    example: 'HSCAN user:1001 0 MATCH "*name*" COUNT 10',
  },
];

// List commands
const LIST_COMMANDS: RedisCommand[] = [
  {
    name: "LPUSH",
    category: "list",
    summary: "Prepend elements to list",
    complexity: "O(N)",
    args: [arg("key", "key"), arg("element", "values", { multiple: true })],
    example: 'LPUSH notifications:user:1001 "New message"',
  },
  {
    name: "RPUSH",
    category: "list",
    summary: "Append elements to list",
    complexity: "O(N)",
    args: [arg("key", "key"), arg("element", "values", { multiple: true })],
    example: 'RPUSH queue:tasks "task1" "task2" "task3"',
  },
  {
    name: "LPOP",
    category: "list",
    summary: "Remove and get first element(s)",
    complexity: "O(N)",
    args: [arg("key", "key"), arg("count", "count", { optional: true })],
    example: "LPOP queue:tasks",
  },
  {
    name: "RPOP",
    category: "list",
    summary: "Remove and get last element(s)",
    complexity: "O(N)",
    args: [arg("key", "key"), arg("count", "count", { optional: true })],
    example: "RPOP queue:tasks 2",
  },
  {
    name: "LRANGE",
    category: "list",
    summary: "Get a range of elements",
    complexity: "O(S+N)",
    args: [arg("key", "key"), arg("start", "index"), arg("stop", "index")],
    example: "LRANGE recent:posts 0 9",
  },
  {
    name: "LINDEX",
    category: "list",
    summary: "Get element by index",
    complexity: "O(N)",
    args: [arg("key", "key"), arg("index", "index")],
    example: "LINDEX mylist 0",
  },
  {
    name: "LSET",
    category: "list",
    summary: "Set element at index",
    complexity: "O(N)",
    args: [arg("key", "key"), arg("index", "index"), arg("element", "value")],
    example: 'LSET mylist 0 "updated_value"',
  },
  {
    name: "LLEN",
    category: "list",
    summary: "Get list length",
    complexity: "O(1)",
    args: [arg("key", "key")],
    example: "LLEN queue:tasks",
  },
  {
    name: "LINSERT",
    category: "list",
    summary: "Insert element before or after pivot",
    complexity: "O(N)",
    args: [
      arg("key", "key"),
      arg("position", "option", { enum: ["BEFORE", "AFTER"] }),
      arg("pivot", "value"),
      arg("element", "value"),
    ],
    example: 'LINSERT mylist BEFORE "pivot" "new_element"',
  },
  {
    name: "LREM",
    category: "list",
    summary: "Remove elements equal to value",
    complexity: "O(N+M)",
    args: [arg("key", "key"), arg("count", "count"), arg("element", "value")],
    example: 'LREM mylist 2 "duplicate"',
  },
  {
    name: "LTRIM",
    category: "list",
    summary: "Trim list to specified range",
    complexity: "O(N)",
    args: [arg("key", "key"), arg("start", "index"), arg("stop", "index")],
    example: "LTRIM recent:activity 0 99",
  },
  {
    name: "BLPOP",
    category: "list",
    summary: "Blocking pop from head",
    complexity: "O(N)",
    args: [arg("key", "keys", { multiple: true }), arg("timeout", "timeout")],
    example: "BLPOP queue:tasks 30",
  },
  {
    name: "BRPOP",
    category: "list",
    summary: "Blocking pop from tail",
    complexity: "O(N)",
    args: [arg("key", "keys", { multiple: true }), arg("timeout", "timeout")],
    example: "BRPOP queue:tasks 30",
  },
  {
    name: "LMOVE",
    category: "list",
    summary: "Move element between lists",
    complexity: "O(1)",
    args: [
      arg("source", "key"),
      arg("destination", "key"),
      arg("wherefrom", "option", { enum: ["LEFT", "RIGHT"] }),
      arg("whereto", "option", { enum: ["LEFT", "RIGHT"] }),
    ],
    example: "LMOVE source dest LEFT RIGHT",
  },
];

// Set commands
const SET_COMMANDS: RedisCommand[] = [
  {
    name: "SADD",
    category: "set",
    summary: "Add members to a set",
    complexity: "O(N)",
    args: [arg("key", "key"), arg("member", "members", { multiple: true })],
    example: 'SADD tags:article:1001 "redis" "database" "nosql"',
  },
  {
    name: "SREM",
    category: "set",
    summary: "Remove members from a set",
    complexity: "O(N)",
    args: [arg("key", "key"), arg("member", "members", { multiple: true })],
    example: 'SREM tags:article:1001 "old_tag"',
  },
  {
    name: "SMEMBERS",
    category: "set",
    summary: "Get all members in a set",
    complexity: "O(N)",
    args: [arg("key", "key")],
    example: "SMEMBERS tags:article:1001",
  },
  {
    name: "SISMEMBER",
    category: "set",
    summary: "Check if member exists in set",
    complexity: "O(1)",
    args: [arg("key", "key"), arg("member", "member")],
    example: 'SISMEMBER users:online "user:1001"',
  },
  {
    name: "SCARD",
    category: "set",
    summary: "Get the number of members in a set",
    complexity: "O(1)",
    args: [arg("key", "key")],
    example: "SCARD users:online",
  },
  {
    name: "SINTER",
    category: "set",
    summary: "Intersect multiple sets",
    complexity: "O(N*M)",
    args: [arg("key", "keys", { multiple: true })],
    example: "SINTER user:1:friends user:2:friends",
  },
  {
    name: "SINTERSTORE",
    category: "set",
    summary: "Intersect and store result",
    complexity: "O(N*M)",
    args: [arg("destination", "key"), arg("key", "keys", { multiple: true })],
    example: "SINTERSTORE mutual:friends user:1:friends user:2:friends",
  },
  {
    name: "SUNION",
    category: "set",
    summary: "Union of multiple sets",
    complexity: "O(N)",
    args: [arg("key", "keys", { multiple: true })],
    example: "SUNION tags:post:1 tags:post:2 tags:post:3",
  },
  {
    name: "SUNIONSTORE",
    category: "set",
    summary: "Union and store result",
    complexity: "O(N)",
    args: [arg("destination", "key"), arg("key", "keys", { multiple: true })],
    example: "SUNIONSTORE all:tags tags:post:1 tags:post:2",
  },
  {
    name: "SDIFF",
    category: "set",
    summary: "Difference between sets",
    complexity: "O(N)",
    args: [arg("key", "keys", { multiple: true })],
    example: "SDIFF user:1:friends user:2:friends",
  },
  {
    name: "SDIFFSTORE",
    category: "set",
    summary: "Difference and store result",
    complexity: "O(N)",
    args: [arg("destination", "key"), arg("key", "keys", { multiple: true })],
    example: "SDIFFSTORE unique:friends user:1:friends user:2:friends",
  },
  {
    name: "SPOP",
    category: "set",
    summary: "Remove and return random member(s)",
    complexity: "O(N)",
    args: [arg("key", "key"), arg("count", "count", { optional: true })],
    example: "SPOP lottery:entries 3",
  },
  {
    name: "SRANDMEMBER",
    category: "set",
    summary: "Get random member(s)",
    complexity: "O(N)",
    args: [arg("key", "key"), arg("count", "count", { optional: true })],
    example: "SRANDMEMBER featured:products 5",
  },
  {
    name: "SMOVE",
    category: "set",
    summary: "Move member between sets",
    complexity: "O(1)",
    args: [arg("source", "key"), arg("destination", "key"), arg("member", "member")],
    example: 'SMOVE pending completed "task:1001"',
  },
  {
    name: "SSCAN",
    category: "set",
    summary: "Iterate set members",
    complexity: "O(N)",
    args: [arg("key", "key"), arg("cursor", "cursor")],
    options: [
      { name: "MATCH", args: [arg("pattern", "pattern")], description: "Match pattern" },
      { name: "COUNT", args: [arg("count", "count")], description: "Return count hint" },
    ],
    example: 'SSCAN users:online 0 MATCH "user:*" COUNT 100',
  },
];

// Sorted Set commands
const SORTED_SET_COMMANDS: RedisCommand[] = [
  {
    name: "ZADD",
    category: "sortedset",
    summary: "Add members with scores to sorted set",
    complexity: "O(log(N))",
    args: [arg("key", "key"), arg("score", "score"), arg("member", "member", { multiple: true })],
    options: [
      { name: "NX", description: "Only add new elements" },
      { name: "XX", description: "Only update existing elements" },
      { name: "GT", description: "Only update if new score > current" },
      { name: "LT", description: "Only update if new score < current" },
      { name: "CH", description: "Return number of changed elements" },
      { name: "INCR", description: "Increment score instead of set" },
    ],
    example: 'ZADD leaderboard 1000 "player:1001" 950 "player:1002"',
  },
  {
    name: "ZREM",
    category: "sortedset",
    summary: "Remove members from sorted set",
    complexity: "O(M*log(N))",
    args: [arg("key", "key"), arg("member", "members", { multiple: true })],
    example: 'ZREM leaderboard "player:inactive"',
  },
  {
    name: "ZSCORE",
    category: "sortedset",
    summary: "Get the score of a member",
    complexity: "O(1)",
    args: [arg("key", "key"), arg("member", "member")],
    example: 'ZSCORE leaderboard "player:1001"',
  },
  {
    name: "ZRANK",
    category: "sortedset",
    summary: "Get the rank of a member (low to high)",
    complexity: "O(log(N))",
    args: [arg("key", "key"), arg("member", "member")],
    example: 'ZRANK leaderboard "player:1001"',
  },
  {
    name: "ZREVRANK",
    category: "sortedset",
    summary: "Get the rank of a member (high to low)",
    complexity: "O(log(N))",
    args: [arg("key", "key"), arg("member", "member")],
    example: 'ZREVRANK leaderboard "player:1001"',
  },
  {
    name: "ZRANGE",
    category: "sortedset",
    summary: "Get a range of members by rank",
    complexity: "O(log(N)+M)",
    args: [arg("key", "key"), arg("start", "index"), arg("stop", "index")],
    options: [
      { name: "WITHSCORES", description: "Include scores in output" },
      { name: "REV", description: "Reverse order" },
      { name: "BYSCORE", description: "Use score range" },
      { name: "BYLEX", description: "Use lex range" },
      { name: "LIMIT", args: [arg("offset", "index"), arg("count", "count")], description: "Limit results" },
    ],
    example: "ZRANGE leaderboard 0 9 WITHSCORES",
  },
  {
    name: "ZREVRANGE",
    category: "sortedset",
    summary: "Get a range of members (high to low)",
    complexity: "O(log(N)+M)",
    args: [arg("key", "key"), arg("start", "index"), arg("stop", "index")],
    options: [{ name: "WITHSCORES", description: "Include scores" }],
    example: "ZREVRANGE leaderboard 0 9 WITHSCORES",
  },
  {
    name: "ZRANGEBYSCORE",
    category: "sortedset",
    summary: "Get members by score range",
    complexity: "O(log(N)+M)",
    args: [arg("key", "key"), arg("min", "score"), arg("max", "score")],
    options: [
      { name: "WITHSCORES", description: "Include scores" },
      { name: "LIMIT", args: [arg("offset", "index"), arg("count", "count")], description: "Limit results" },
    ],
    example: "ZRANGEBYSCORE scores 100 200 WITHSCORES LIMIT 0 10",
  },
  {
    name: "ZCARD",
    category: "sortedset",
    summary: "Get the number of members",
    complexity: "O(1)",
    args: [arg("key", "key")],
    example: "ZCARD leaderboard",
  },
  {
    name: "ZCOUNT",
    category: "sortedset",
    summary: "Count members in a score range",
    complexity: "O(log(N))",
    args: [arg("key", "key"), arg("min", "score"), arg("max", "score")],
    example: "ZCOUNT leaderboard 100 500",
  },
  {
    name: "ZINCRBY",
    category: "sortedset",
    summary: "Increment the score of a member",
    complexity: "O(log(N))",
    args: [arg("key", "key"), arg("increment", "score"), arg("member", "member")],
    example: 'ZINCRBY leaderboard 10 "player:1001"',
  },
  {
    name: "ZPOPMIN",
    category: "sortedset",
    summary: "Remove lowest scoring members",
    complexity: "O(log(N)*M)",
    args: [arg("key", "key"), arg("count", "count", { optional: true })],
    example: "ZPOPMIN waiting:queue 1",
  },
  {
    name: "ZPOPMAX",
    category: "sortedset",
    summary: "Remove highest scoring members",
    complexity: "O(log(N)*M)",
    args: [arg("key", "key"), arg("count", "count", { optional: true })],
    example: "ZPOPMAX leaderboard 3",
  },
  {
    name: "ZSCAN",
    category: "sortedset",
    summary: "Iterate sorted set members",
    complexity: "O(N)",
    args: [arg("key", "key"), arg("cursor", "cursor")],
    options: [
      { name: "MATCH", args: [arg("pattern", "pattern")], description: "Match pattern" },
      { name: "COUNT", args: [arg("count", "count")], description: "Return count hint" },
    ],
    example: 'ZSCAN leaderboard 0 MATCH "player:*" COUNT 100',
  },
];

// Key commands
const KEY_COMMANDS: RedisCommand[] = [
  {
    name: "KEYS",
    category: "key",
    summary: "Find keys matching pattern (use SCAN in production)",
    complexity: "O(N)",
    args: [arg("pattern", "pattern")],
    example: "KEYS user:*",
  },
  {
    name: "SCAN",
    category: "key",
    summary: "Iterate keys safely",
    complexity: "O(N)",
    args: [arg("cursor", "cursor")],
    options: [
      { name: "MATCH", args: [arg("pattern", "pattern")], description: "Match pattern" },
      { name: "COUNT", args: [arg("count", "count")], description: "Return count hint" },
      { name: "TYPE", args: [arg("type", "option", { enum: ["string", "list", "set", "zset", "hash", "stream"] })], description: "Filter by type" },
    ],
    example: "SCAN 0 MATCH user:* COUNT 100 TYPE hash",
  },
  {
    name: "EXISTS",
    category: "key",
    summary: "Check if key(s) exist",
    complexity: "O(N)",
    args: [arg("key", "keys", { multiple: true })],
    example: "EXISTS user:1001 user:1002 user:1003",
  },
  {
    name: "DEL",
    category: "key",
    summary: "Delete key(s)",
    complexity: "O(N)",
    args: [arg("key", "keys", { multiple: true })],
    example: "DEL temp:key1 temp:key2",
  },
  {
    name: "UNLINK",
    category: "key",
    summary: "Delete key(s) asynchronously",
    complexity: "O(1)",
    args: [arg("key", "keys", { multiple: true })],
    example: "UNLINK large:key1 large:key2",
  },
  {
    name: "TYPE",
    category: "key",
    summary: "Get the type of a key",
    complexity: "O(1)",
    args: [arg("key", "key")],
    example: "TYPE user:1001",
  },
  {
    name: "TTL",
    category: "key",
    summary: "Get time to live in seconds",
    complexity: "O(1)",
    args: [arg("key", "key")],
    example: "TTL session:abc123",
  },
  {
    name: "PTTL",
    category: "key",
    summary: "Get time to live in milliseconds",
    complexity: "O(1)",
    args: [arg("key", "key")],
    example: "PTTL session:abc123",
  },
  {
    name: "EXPIRE",
    category: "key",
    summary: "Set a key's time to live in seconds",
    complexity: "O(1)",
    args: [arg("key", "key"), arg("seconds", "timeout")],
    options: [
      { name: "NX", description: "Only set if no expiry" },
      { name: "XX", description: "Only set if has expiry" },
      { name: "GT", description: "Only set if new expiry > current" },
      { name: "LT", description: "Only set if new expiry < current" },
    ],
    example: "EXPIRE cache:data 3600",
  },
  {
    name: "PEXPIRE",
    category: "key",
    summary: "Set a key's time to live in milliseconds",
    complexity: "O(1)",
    args: [arg("key", "key"), arg("milliseconds", "milliseconds")],
    example: "PEXPIRE temp:data 60000",
  },
  {
    name: "EXPIREAT",
    category: "key",
    summary: "Set expiration at Unix timestamp",
    complexity: "O(1)",
    args: [arg("key", "key"), arg("timestamp", "timestamp")],
    example: "EXPIREAT mykey 1735689600",
  },
  {
    name: "PERSIST",
    category: "key",
    summary: "Remove the expiration from a key",
    complexity: "O(1)",
    args: [arg("key", "key")],
    example: "PERSIST user:1001",
  },
  {
    name: "RENAME",
    category: "key",
    summary: "Rename a key",
    complexity: "O(1)",
    args: [arg("key", "key"), arg("newkey", "key")],
    example: "RENAME old:key new:key",
  },
  {
    name: "RENAMENX",
    category: "key",
    summary: "Rename a key if new key doesn't exist",
    complexity: "O(1)",
    args: [arg("key", "key"), arg("newkey", "key")],
    example: "RENAMENX temp:key final:key",
  },
  {
    name: "COPY",
    category: "key",
    summary: "Copy a key",
    complexity: "O(N)",
    args: [arg("source", "key"), arg("destination", "key")],
    options: [
      { name: "REPLACE", description: "Replace destination if exists" },
      { name: "DB", args: [arg("destination-db", "count")], description: "Target database" },
    ],
    example: "COPY user:1001 user:1001:backup REPLACE",
  },
  {
    name: "RANDOMKEY",
    category: "key",
    summary: "Return a random key",
    complexity: "O(1)",
    args: [],
    example: "RANDOMKEY",
  },
];

// Stream commands
const STREAM_COMMANDS: RedisCommand[] = [
  {
    name: "XADD",
    category: "stream",
    summary: "Add entry to stream",
    complexity: "O(1)",
    args: [
      arg("key", "key"),
      arg("ID", "stream-id", { description: "Use * for auto-generate" }),
      arg("field", "field"),
      arg("value", "value", { multiple: true }),
    ],
    options: [
      { name: "NOMKSTREAM", description: "Don't create stream if not exists" },
      { name: "MAXLEN", args: [arg("count", "count")], description: "Trim to max length" },
      { name: "MINID", args: [arg("threshold", "stream-id")], description: "Trim by ID" },
    ],
    example: 'XADD events:user * action "login" user_id "1001"',
  },
  {
    name: "XREAD",
    category: "stream",
    summary: "Read from stream(s)",
    complexity: "O(N)",
    args: [
      arg("STREAMS", "subcommand"),
      arg("key", "keys", { multiple: true }),
      arg("ID", "stream-id", { multiple: true }),
    ],
    options: [
      { name: "COUNT", args: [arg("count", "count")], description: "Max entries" },
      { name: "BLOCK", args: [arg("milliseconds", "milliseconds")], description: "Block timeout" },
    ],
    example: "XREAD COUNT 10 STREAMS events:user 0",
  },
  {
    name: "XRANGE",
    category: "stream",
    summary: "Get entries in a range",
    complexity: "O(N)",
    args: [
      arg("key", "key"),
      arg("start", "stream-id", { description: "Use - for earliest" }),
      arg("end", "stream-id", { description: "Use + for latest" }),
    ],
    options: [{ name: "COUNT", args: [arg("count", "count")], description: "Limit count" }],
    example: "XRANGE events:user - + COUNT 100",
  },
  {
    name: "XLEN",
    category: "stream",
    summary: "Get stream length",
    complexity: "O(1)",
    args: [arg("key", "key")],
    example: "XLEN events:user",
  },
  {
    name: "XINFO STREAM",
    fullName: "XINFO STREAM",
    category: "stream",
    summary: "Get stream information",
    complexity: "O(1)",
    args: [arg("key", "key")],
    options: [{ name: "FULL", description: "Get full info" }],
    example: "XINFO STREAM events:user",
  },
  {
    name: "XINFO GROUPS",
    fullName: "XINFO GROUPS",
    category: "stream",
    summary: "Get consumer groups",
    complexity: "O(N)",
    args: [arg("key", "key")],
    example: "XINFO GROUPS events:user",
  },
  {
    name: "XGROUP CREATE",
    fullName: "XGROUP CREATE",
    category: "stream",
    summary: "Create consumer group",
    complexity: "O(1)",
    args: [arg("key", "key"), arg("groupname", "group"), arg("ID", "stream-id")],
    options: [{ name: "MKSTREAM", description: "Create stream if not exists" }],
    example: "XGROUP CREATE events:user processors $ MKSTREAM",
  },
  {
    name: "XREADGROUP",
    category: "stream",
    summary: "Read as consumer group member",
    complexity: "O(N)",
    args: [
      arg("GROUP", "subcommand"),
      arg("group", "group"),
      arg("consumer", "consumer"),
      arg("STREAMS", "subcommand"),
      arg("key", "key"),
      arg("ID", "stream-id"),
    ],
    options: [
      { name: "COUNT", args: [arg("count", "count")], description: "Max entries" },
      { name: "BLOCK", args: [arg("milliseconds", "milliseconds")], description: "Block timeout" },
      { name: "NOACK", description: "Don't add to PEL" },
    ],
    example: "XREADGROUP GROUP processors worker1 COUNT 10 STREAMS events:user >",
  },
  {
    name: "XACK",
    category: "stream",
    summary: "Acknowledge message(s)",
    complexity: "O(N)",
    args: [arg("key", "key"), arg("group", "group"), arg("ID", "stream-id", { multiple: true })],
    example: "XACK events:user processors 1526569495631-0",
  },
  {
    name: "XPENDING",
    category: "stream",
    summary: "Get pending entries",
    complexity: "O(N)",
    args: [arg("key", "key"), arg("group", "group")],
    options: [
      { name: "IDLE", args: [arg("min-idle-time", "milliseconds")], description: "Min idle time" },
    ],
    example: "XPENDING events:user processors - + 10",
  },
  {
    name: "XTRIM",
    category: "stream",
    summary: "Trim stream",
    complexity: "O(N)",
    args: [arg("key", "key")],
    options: [
      { name: "MAXLEN", args: [arg("count", "count")], description: "Max length" },
      { name: "MINID", args: [arg("threshold", "stream-id")], description: "Min ID" },
    ],
    example: "XTRIM events:user MAXLEN ~ 1000",
  },
];

// Server commands
const SERVER_COMMANDS: RedisCommand[] = [
  {
    name: "PING",
    category: "server",
    summary: "Test connection",
    complexity: "O(1)",
    args: [arg("message", "message", { optional: true })],
    example: "PING",
  },
  {
    name: "INFO",
    category: "server",
    summary: "Get server information",
    complexity: "O(1)",
    args: [arg("section", "option", { optional: true, enum: ["server", "clients", "memory", "persistence", "stats", "replication", "cpu", "cluster", "keyspace", "modules"] })],
    example: "INFO memory",
  },
  {
    name: "DBSIZE",
    category: "server",
    summary: "Get number of keys in database",
    complexity: "O(1)",
    args: [],
    example: "DBSIZE",
  },
  {
    name: "SELECT",
    category: "connection",
    summary: "Switch database (0-15)",
    complexity: "O(1)",
    args: [arg("index", "count")],
    example: "SELECT 1",
  },
  {
    name: "FLUSHDB",
    category: "server",
    summary: "Delete all keys in current database",
    complexity: "O(N)",
    args: [],
    options: [
      { name: "ASYNC", description: "Delete asynchronously" },
      { name: "SYNC", description: "Delete synchronously" },
    ],
    example: "FLUSHDB ASYNC",
  },
  {
    name: "FLUSHALL",
    category: "server",
    summary: "Delete all keys in all databases",
    complexity: "O(N)",
    args: [],
    options: [
      { name: "ASYNC", description: "Delete asynchronously" },
      { name: "SYNC", description: "Delete synchronously" },
    ],
    example: "FLUSHALL ASYNC",
  },
  {
    name: "CONFIG GET",
    fullName: "CONFIG GET",
    category: "server",
    summary: "Get configuration parameter",
    complexity: "O(N)",
    args: [arg("parameter", "pattern")],
    example: "CONFIG GET maxmemory",
  },
  {
    name: "CONFIG SET",
    fullName: "CONFIG SET",
    category: "server",
    summary: "Set configuration parameter",
    complexity: "O(1)",
    args: [arg("parameter", "key"), arg("value", "value")],
    example: "CONFIG SET maxmemory 256mb",
  },
  {
    name: "CLIENT LIST",
    fullName: "CLIENT LIST",
    category: "connection",
    summary: "List connected clients",
    complexity: "O(N)",
    args: [],
    example: "CLIENT LIST",
  },
  {
    name: "CLIENT SETNAME",
    fullName: "CLIENT SETNAME",
    category: "connection",
    summary: "Set client connection name",
    complexity: "O(1)",
    args: [arg("name", "value")],
    example: "CLIENT SETNAME myapp",
  },
  {
    name: "MEMORY USAGE",
    fullName: "MEMORY USAGE",
    category: "server",
    summary: "Get memory usage of a key",
    complexity: "O(N)",
    args: [arg("key", "key")],
    example: "MEMORY USAGE user:1001",
  },
  {
    name: "SLOWLOG GET",
    fullName: "SLOWLOG GET",
    category: "server",
    summary: "Get slow query log",
    complexity: "O(N)",
    args: [arg("count", "count", { optional: true })],
    example: "SLOWLOG GET 10",
  },
  {
    name: "TIME",
    category: "server",
    summary: "Get server time",
    complexity: "O(1)",
    args: [],
    example: "TIME",
  },
  {
    name: "BGSAVE",
    category: "server",
    summary: "Trigger background save",
    complexity: "O(1)",
    args: [],
    example: "BGSAVE",
  },
];

// Transaction commands
const TRANSACTION_COMMANDS: RedisCommand[] = [
  {
    name: "MULTI",
    category: "transaction",
    summary: "Start a transaction",
    complexity: "O(1)",
    args: [],
    example: "MULTI",
  },
  {
    name: "EXEC",
    category: "transaction",
    summary: "Execute queued commands",
    complexity: "O(N)",
    args: [],
    example: "EXEC",
  },
  {
    name: "DISCARD",
    category: "transaction",
    summary: "Discard queued commands",
    complexity: "O(N)",
    args: [],
    example: "DISCARD",
  },
  {
    name: "WATCH",
    category: "transaction",
    summary: "Watch keys for changes",
    complexity: "O(N)",
    args: [arg("key", "keys", { multiple: true })],
    example: "WATCH user:1001:balance",
  },
  {
    name: "UNWATCH",
    category: "transaction",
    summary: "Unwatch all keys",
    complexity: "O(1)",
    args: [],
    example: "UNWATCH",
  },
];

// Pub/Sub commands
const PUBSUB_COMMANDS: RedisCommand[] = [
  {
    name: "PUBLISH",
    category: "pubsub",
    summary: "Publish message to channel",
    complexity: "O(N+M)",
    args: [arg("channel", "channel"), arg("message", "message")],
    example: 'PUBLISH notifications "New order received"',
  },
  {
    name: "SUBSCRIBE",
    category: "pubsub",
    summary: "Subscribe to channel(s)",
    complexity: "O(N)",
    args: [arg("channel", "channel", { multiple: true })],
    example: "SUBSCRIBE notifications alerts",
  },
  {
    name: "PSUBSCRIBE",
    category: "pubsub",
    summary: "Subscribe to patterns",
    complexity: "O(N)",
    args: [arg("pattern", "pattern", { multiple: true })],
    example: "PSUBSCRIBE events:* alerts:*",
  },
  {
    name: "UNSUBSCRIBE",
    category: "pubsub",
    summary: "Unsubscribe from channel(s)",
    complexity: "O(N)",
    args: [arg("channel", "channel", { optional: true, multiple: true })],
    example: "UNSUBSCRIBE notifications",
  },
  {
    name: "PUBSUB CHANNELS",
    fullName: "PUBSUB CHANNELS",
    category: "pubsub",
    summary: "List active channels",
    complexity: "O(N)",
    args: [arg("pattern", "pattern", { optional: true })],
    example: "PUBSUB CHANNELS notifications:*",
  },
  {
    name: "PUBSUB NUMSUB",
    fullName: "PUBSUB NUMSUB",
    category: "pubsub",
    summary: "Count subscribers to channels",
    complexity: "O(N)",
    args: [arg("channel", "channel", { optional: true, multiple: true })],
    example: "PUBSUB NUMSUB notifications alerts",
  },
];

// Scripting commands
const SCRIPTING_COMMANDS: RedisCommand[] = [
  {
    name: "EVAL",
    category: "scripting",
    summary: "Execute Lua script",
    complexity: "O(1)",
    args: [
      arg("script", "script"),
      arg("numkeys", "count"),
      arg("key", "keys", { optional: true, multiple: true }),
      arg("arg", "values", { optional: true, multiple: true }),
    ],
    example: `EVAL "return redis.call('GET', KEYS[1])" 1 mykey`,
  },
  {
    name: "EVALSHA",
    category: "scripting",
    summary: "Execute cached Lua script by SHA1",
    complexity: "O(1)",
    args: [
      arg("sha1", "sha1"),
      arg("numkeys", "count"),
      arg("key", "keys", { optional: true, multiple: true }),
      arg("arg", "values", { optional: true, multiple: true }),
    ],
    example: "EVALSHA d41d8cd98f00b204e9800998ecf8427e 1 mykey",
  },
  {
    name: "SCRIPT LOAD",
    fullName: "SCRIPT LOAD",
    category: "scripting",
    summary: "Load script into cache",
    complexity: "O(N)",
    args: [arg("script", "script")],
    example: `SCRIPT LOAD "return redis.call('GET', KEYS[1])"`,
  },
  {
    name: "SCRIPT EXISTS",
    fullName: "SCRIPT EXISTS",
    category: "scripting",
    summary: "Check if scripts exist in cache",
    complexity: "O(N)",
    args: [arg("sha1", "sha1", { multiple: true })],
    example: "SCRIPT EXISTS d41d8cd98f00b204e9800998ecf8427e",
  },
  {
    name: "SCRIPT FLUSH",
    fullName: "SCRIPT FLUSH",
    category: "scripting",
    summary: "Clear script cache",
    complexity: "O(N)",
    args: [],
    options: [
      { name: "ASYNC", description: "Flush asynchronously" },
      { name: "SYNC", description: "Flush synchronously" },
    ],
    example: "SCRIPT FLUSH",
  },
];

// Geo commands
const GEO_COMMANDS: RedisCommand[] = [
  {
    name: "GEOADD",
    category: "geo",
    summary: "Add geospatial items",
    complexity: "O(log(N))",
    args: [
      arg("key", "key"),
      arg("longitude", "longitude"),
      arg("latitude", "latitude"),
      arg("member", "member", { multiple: true }),
    ],
    options: [
      { name: "NX", description: "Only add new elements" },
      { name: "XX", description: "Only update existing" },
      { name: "CH", description: "Return changed count" },
    ],
    example: 'GEOADD stores -122.4194 37.7749 "store:sf" -73.9857 40.7484 "store:nyc"',
  },
  {
    name: "GEOPOS",
    category: "geo",
    summary: "Get position(s) of member(s)",
    complexity: "O(N)",
    args: [arg("key", "key"), arg("member", "members", { multiple: true })],
    example: 'GEOPOS stores "store:sf" "store:nyc"',
  },
  {
    name: "GEODIST",
    category: "geo",
    summary: "Get distance between two members",
    complexity: "O(1)",
    args: [
      arg("key", "key"),
      arg("member1", "member"),
      arg("member2", "member"),
      arg("unit", "unit", { optional: true, enum: ["m", "km", "ft", "mi"] }),
    ],
    example: 'GEODIST stores "store:sf" "store:nyc" km',
  },
  {
    name: "GEORADIUS",
    category: "geo",
    summary: "Query by radius from coordinates",
    complexity: "O(N+log(M))",
    args: [
      arg("key", "key"),
      arg("longitude", "longitude"),
      arg("latitude", "latitude"),
      arg("radius", "radius"),
      arg("unit", "unit", { enum: ["m", "km", "ft", "mi"] }),
    ],
    options: [
      { name: "WITHCOORD", description: "Include coordinates" },
      { name: "WITHDIST", description: "Include distance" },
      { name: "WITHHASH", description: "Include geohash" },
      { name: "COUNT", args: [arg("count", "count")], description: "Limit results" },
      { name: "ASC", description: "Sort ascending" },
      { name: "DESC", description: "Sort descending" },
    ],
    example: "GEORADIUS stores -122.4194 37.7749 100 km WITHDIST COUNT 10",
  },
  {
    name: "GEOSEARCH",
    category: "geo",
    summary: "Search geospatial data",
    complexity: "O(N+log(M))",
    args: [arg("key", "key")],
    options: [
      { name: "FROMMEMBER", args: [arg("member", "member")], description: "Search from member" },
      { name: "FROMLONLAT", args: [arg("lon", "longitude"), arg("lat", "latitude")], description: "Search from coordinates" },
      { name: "BYRADIUS", args: [arg("radius", "radius"), arg("unit", "unit", { enum: ["m", "km", "ft", "mi"] })], description: "Search by radius" },
      { name: "BYBOX", args: [arg("width", "radius"), arg("height", "radius"), arg("unit", "unit", { enum: ["m", "km", "ft", "mi"] })], description: "Search by box" },
      { name: "ASC", description: "Sort ascending" },
      { name: "DESC", description: "Sort descending" },
      { name: "COUNT", args: [arg("count", "count")], description: "Limit results" },
      { name: "WITHCOORD", description: "Include coordinates" },
      { name: "WITHDIST", description: "Include distance" },
    ],
    example: 'GEOSEARCH stores FROMMEMBER "store:sf" BYRADIUS 100 km ASC COUNT 5',
  },
];

// HyperLogLog commands
const HYPERLOGLOG_COMMANDS: RedisCommand[] = [
  {
    name: "PFADD",
    category: "hyperloglog",
    summary: "Add elements to HyperLogLog",
    complexity: "O(1)",
    args: [arg("key", "key"), arg("element", "values", { multiple: true })],
    example: 'PFADD visitors:today "user:1001" "user:1002" "user:1003"',
  },
  {
    name: "PFCOUNT",
    category: "hyperloglog",
    summary: "Get cardinality estimate",
    complexity: "O(1)/O(N)",
    args: [arg("key", "keys", { multiple: true })],
    example: "PFCOUNT visitors:today visitors:yesterday",
  },
  {
    name: "PFMERGE",
    category: "hyperloglog",
    summary: "Merge HyperLogLogs",
    complexity: "O(N)",
    args: [arg("destkey", "key"), arg("sourcekey", "keys", { multiple: true })],
    example: "PFMERGE visitors:week visitors:mon visitors:tue",
  },
];

// Bitmap commands
const BITMAP_COMMANDS: RedisCommand[] = [
  {
    name: "SETBIT",
    category: "bitmap",
    summary: "Set bit at offset",
    complexity: "O(1)",
    args: [arg("key", "key"), arg("offset", "index"), arg("value", "count", { enum: ["0", "1"] })],
    example: "SETBIT user:1001:logins 0 1",
  },
  {
    name: "GETBIT",
    category: "bitmap",
    summary: "Get bit at offset",
    complexity: "O(1)",
    args: [arg("key", "key"), arg("offset", "index")],
    example: "GETBIT user:1001:logins 0",
  },
  {
    name: "BITCOUNT",
    category: "bitmap",
    summary: "Count set bits in a range",
    complexity: "O(N)",
    args: [
      arg("key", "key"),
      arg("start", "index", { optional: true }),
      arg("end", "index", { optional: true }),
    ],
    example: "BITCOUNT user:1001:logins",
  },
  {
    name: "BITOP",
    category: "bitmap",
    summary: "Perform bitwise operation",
    complexity: "O(N)",
    args: [
      arg("operation", "option", { enum: ["AND", "OR", "XOR", "NOT"] }),
      arg("destkey", "key"),
      arg("key", "keys", { multiple: true }),
    ],
    example: "BITOP AND result key1 key2",
  },
  {
    name: "BITPOS",
    category: "bitmap",
    summary: "Find first bit set or clear",
    complexity: "O(N)",
    args: [
      arg("key", "key"),
      arg("bit", "count", { enum: ["0", "1"] }),
      arg("start", "index", { optional: true }),
      arg("end", "index", { optional: true }),
    ],
    example: "BITPOS user:logins 1",
  },
];

// All commands combined
export const REDIS_COMMANDS: RedisCommand[] = [
  ...STRING_COMMANDS,
  ...HASH_COMMANDS,
  ...LIST_COMMANDS,
  ...SET_COMMANDS,
  ...SORTED_SET_COMMANDS,
  ...KEY_COMMANDS,
  ...STREAM_COMMANDS,
  ...SERVER_COMMANDS,
  ...TRANSACTION_COMMANDS,
  ...PUBSUB_COMMANDS,
  ...SCRIPTING_COMMANDS,
  ...GEO_COMMANDS,
  ...HYPERLOGLOG_COMMANDS,
  ...BITMAP_COMMANDS,
];

// Command lookup by name (uppercase)
export const COMMAND_MAP = new Map<string, RedisCommand>(
  REDIS_COMMANDS.map((cmd) => [(cmd.fullName || cmd.name).toUpperCase(), cmd])
);

// Get command by name
export function getCommand(name: string): RedisCommand | undefined {
  return COMMAND_MAP.get(name.toUpperCase());
}

// Get commands by category
export function getCommandsByCategory(category: RedisCommand["category"]): RedisCommand[] {
  return REDIS_COMMANDS.filter((cmd) => cmd.category === category);
}

// Search commands by prefix
export function searchCommands(prefix: string): RedisCommand[] {
  const upper = prefix.toUpperCase();
  return REDIS_COMMANDS.filter(
    (cmd) =>
      cmd.name.toUpperCase().startsWith(upper) ||
      (cmd.fullName && cmd.fullName.toUpperCase().startsWith(upper))
  );
}
